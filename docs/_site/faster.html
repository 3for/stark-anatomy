<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Anatomy of a STARK, Part 6: Speeding Things Up | Anatomy of a STARK</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Anatomy of a STARK, Part 6: Speeding Things Up" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="STARK tutorial with supporting source code in python." />
<meta property="og:description" content="STARK tutorial with supporting source code in python." />
<link rel="canonical" href="http://localhost:4000/faster.html" />
<meta property="og:url" content="http://localhost:4000/faster.html" />
<meta property="og:site_name" content="Anatomy of a STARK" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Anatomy of a STARK, Part 6: Speeding Things Up" />
<script type="application/ld+json">
{"description":"STARK tutorial with supporting source code in python.","@type":"WebPage","headline":"Anatomy of a STARK, Part 6: Speeding Things Up","url":"http://localhost:4000/faster.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Anatomy of a STARK" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Anatomy of a STARK</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/basic-tools.html">Anatomy of a STARK, Part 2: Basic Tools</a><a class="page-link" href="/faster.html">Anatomy of a STARK, Part 6: Speeding Things Up</a><a class="page-link" href="/fri.html">Anatomy of a STARK, Part 3: FRI</a><a class="page-link" href="/introduction.html">Anatomy of a STARK, Part 0: Introduction</a><a class="page-link" href="/overview.html">Anatomy of a STARK, Part 1: STARK Overview</a><a class="page-link" href="/rescue-prime.html">Anatomy of a STARK, Part 5: A Rescue-Prime STARK</a><a class="page-link" href="/stark.html">Anatomy of a STARK, Part 4: The STARK Polynomial IOP</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Anatomy of a STARK, Part 6: Speeding Things Up</h1>
  </header>

  <div class="post-content">
    <h1 id="anatomy-of-a-stark-part-6-speeding-things-up">Anatomy of a STARK, Part 6: Speeding Things Up</h1>

<p>The previous part of this tutorial posed the question whether maths-level improvement can reduce the running times of the STARK algorithms. Indeed they can! There are folklore computational algebra tricks are folklore that are independent of the STARK machinery, as well as some techniques specific to interactive proof systems.</p>

<h2 id="the-number-theoretic-transform-and-its-applications">The Number Theoretic Transform and its Applications</h2>

<h3 id="the-fast-fourier-transform">The Fast Fourier Transform</h3>

<p>Let $f(X)$ be a polynomial of degree at most $2^k - 1$ with complex numbers as coefficients. What is the most efficient way to find the list of evaluations $f(X)$ on the $2^k$ complex roots of unity? Specifically, let $\omega = e^{2 \pi i / 2^k}$, then the output of the algorithm should be $(f(\omega^i))_{i=0}^{2^k-1} = (f(1), f(\omega), f(\omega^2), \ldots, f(\omega^{2^k-1}))$.</p>

<p>The naïve solution is to sequentially compute each evaluation individually. A more intelligent solution relies on the observation that $f(\omega^i) = \sum_{j=0}^{2^k-1} \omega^{ij} f_j$ and splitting the even and odd terms gives
\(f(\omega^i) = \sum_{j=0}^{2^{k-1}-1} \omega^{i(2j)}f_{2j} + \sum_{j=0}^{2^{k-1}-1} \omega^{i(2j+1)} f_{2j+1} \\
 = \sum_{j=0}^{2^{k-1}-1} \omega^{i(2j)}f_{2j} + \omega^i \cdot \sum_{j=0}^{2^{k-1}-1} \omega^{i(2j)} f_{2j+1} \\
 = f_E(\omega^{2i}) + \omega^i \cdot f_O(\omega^{2i}) \enspace ,\)
where $f_E(X)$ and $f_O(X)$ are the polynomials whose coefficients are the even coefficients, and odd coefficients respectively, of $f(X)$.</p>

<p>In other words, the evaluation of $f(X)$ at $\omega^i$ can be described in terms of the evaluations of $f_E(X)$ and $f_O(X)$ at $\omega^{2i}$. The same is true for a batch of points ${\omega^{ij}}<em>{j=0}^{2^k-1}$, in which case the values of $f_E(X)$ and $f_O(X)$ on a domain of only half the size are needed: ${(\omega^{ij})^2}</em>{j=0}^{2^k-1} = {(\omega^{2i})^j}_{j=0}^{2^{k-1}-1}$. Note that tasks of batch-evaluating $f_E(X)$ and $f_O(X)$ are independent tasks of half the size. This screams divide and conquer! Specifically, the following strategy suggests itself:</p>
<ul>
  <li>split coefficient vector into even and odd parts;</li>
  <li>evaluate $f_E(X)$ on ${(\omega^{2i})^j}_{j=0}^{2^{k-1}-1}$ by recursion;</li>
  <li>evaluate $f_O(X)$ on ${(\omega^{2i})^j}_{j=0}^{2^{k-1}-1}$ by recursion;</li>
  <li>merge the evaluation vectors using the formula $f(\omega^i) = f_E(\omega^{2i}) + \omega^i \cdot f_O(\omega^{2i})$.</li>
</ul>

<p>Vòilá! That’s the fast Fourier transform (FFT). The reason why the $2^k$th root of unity is needed is because it guarantees that ${(\omega^{ij})^2}<em>{j=0}^{2^k-1} = {(\omega^{2i})^j}</em>{j=0}^{2^{k-1}-1}$, and so the recursion really is on a domain of half the size. Phrased differently, if you were to use a similar strategy to evaluate $f(X)$ in ${z^j}_{j=0}^{2^k-1}$ where $z$ is not a primitive $2^k$th root of unity then the evaluation domain would not shrink with every recursion step. There are $k$ recursion steps, and at each level there are $2^k$ multiplications and additions, so the complexity of this algorithm is $O(2^k \cdot k)$, or expressed in terms of the length of the coefficient vector $N = 2^k$, $O(N \cdot \log N)$. A lot faster than the $O(N^2)$ complexity of the naïve sequential algorithm.</p>

<p>Note that the only property that we need from $\omega$ is that the set of squares ${\omega^j}_{j=0}^{2^k-1}$ is a set of half the size. The number $\omega$ satisfies this property because $\omega^{2^{k-1}+i} = -\omega^i$. Importantly, $\omega$ does not need to be a complex number as long as it satisfies this property. In fact, whenever a finite field has a subgroup of order $2^k$, this subgroup is generated by some $\omega$, and this $\omega$ can be used in exactly the same way. The resulting algorithm is a finite field analogue of the FFT, sometimes called the <em>Number Theory Transform (NTT)</em>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ntt</span><span class="p">(</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">values</span> <span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="s">"cannot compute ntt of non-power-of-two sequence"</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="n">field</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">field</span>

    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"primitive root must be nth root of unity, where n is len(values)"</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"primitive root is not primitive nth root of unity, where n is len(values)"</span>

    <span class="n">half</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">odds</span> <span class="o">=</span> <span class="n">ntt</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">evens</span> <span class="o">=</span> <span class="n">ntt</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">values</span><span class="p">[::</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">evens</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">half</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">odds</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">half</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
</code></pre></div></div>

<p>The real magic comes into play when we apply the FFT (or NTT) twice, but use the inverse of $\omega$ for the second layer. Specifically, what happens if we treat the list of evaluations as a list of polynomial coefficients, and evaluate this polynomial in the $2^k$th roots of unity, in opposite order?</p>

<p>Recall that the $i$th coefficient of the Fourier transform is $f(\omega^i) = \sum_{j=0}^{2^k-1} f_j \omega^{ij}$. So the $l$th coefficient of the double Fourier transform is
\(\sum_{i=0}^{2^k-1} f(\omega^i) \omega^{-il} = \sum_{i=0}^{2^k-1} \left( \sum_{j=0}^{2^k-1} f_j \omega^{ij} \right) \omega^{-il} \\
= \sum_{j=0}^{2^k-1} f_j \sum_{i=0}^{2^k-1} \omega^{i(l-j)} \enspace .\)</p>

<p>Whenever $l-j \neq 0$, the sum $\sum_{i=0}^{2^k-1} \omega^{i(l+j)}$ vanishes. To see this, recall that $\omega^{2^{k-1} + i} = -\omega^i$ for all $i$, so every term in this sum has an equal and opposite term that cancels it. So in the formula above, the only coefficient $f_j$ that is multiplied by a nonzero sum is $f_{l}$, and in fact this sum is $\sum_{i=0}^{1}1 = 2^k$. So in summary, the $l$th coefficient of the double Fourier transform of $\mathbf{f}$ is $2^k \cdot f_{l}$, which is the same as the $l$th coefficient of $\mathbf{f}$ but scaled by a factor $2^k$.</p>

<p>What was derived was an inverse fast Fourier transform. Specifically, this inverse is the same as the regular fast Fourier transform, except</p>
<ul>
  <li>it uses $\omega^{-1}$ instead of $\omega$; and</li>
  <li>it needs to undo the scaling factor $2^k$ on every coefficient.</li>
</ul>

<p>Once again, the logic applies to finite fields that are equipped with a subgroup of order $2^k$ without any change, resulting in the inverse NTT.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">intt</span><span class="p">(</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">values</span> <span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="s">"cannot compute intt of non-power-of-two sequence"</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="n">field</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">field</span>
    <span class="n">ninv</span> <span class="o">=</span> <span class="n">FieldElement</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">field</span><span class="p">).</span><span class="n">inverse</span><span class="p">()</span>

    <span class="n">transformed_values</span> <span class="o">=</span> <span class="n">ntt</span><span class="p">(</span><span class="n">primitive_root</span><span class="p">.</span><span class="n">inverse</span><span class="p">(),</span> <span class="n">values</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ninv</span><span class="o">*</span><span class="n">tv</span> <span class="k">for</span> <span class="n">tv</span> <span class="ow">in</span> <span class="n">transformed_values</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="fast-polynomial-arithmetic">Fast Polynomial Arithmetic</h3>

<p>The NTT is popular in computer algebra because the Fourier transform induces a homomorphism for polynomials and their values. Specifically, multiplication of polynomials corresponds to element-wise multiplication of their Fourier transforms. To see this, apply the formula for the Fourier transform to the formula for the product polynomial. To see why this is true, remember that the Fourier transform represents the <em>evaluations</em> of a polynomial. Clearly, the evaluation of $h(X) = f(X) \cdot g(X)$ in any point $z$ is the product of the evaluations of $f(X)$ and $g(X)$ in $z$. As long as $\mathsf{deg}(h(X)) &lt; 2^k$, we can compute this product by:</p>
<ul>
  <li>computing the NTT;</li>
  <li>miltiplying the resulting vectors element-wise; and</li>
  <li>computing the inverse NTT.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fast_multiply</span><span class="p">(</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span> <span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="n">root_order</span> <span class="o">==</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root does not have supplied order"</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="p">(</span><span class="n">root_order</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root is not primitive root of supplied order"</span>

    <span class="k">if</span> <span class="n">lhs</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()</span> <span class="ow">or</span> <span class="n">rhs</span><span class="p">.</span><span class="n">is_zero</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">Polynomial</span><span class="p">([])</span>

    <span class="n">field</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">field</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">primitive_root</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">root_order</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span>

    <span class="k">while</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="n">order</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">^</span><span class="mi">2</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">lhs_coefficients</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">coefficients</span><span class="p">[:(</span><span class="n">lhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_coefficients</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">lhs_coefficients</span> <span class="o">+=</span> <span class="p">[</span><span class="n">field</span><span class="p">.</span><span class="n">zero</span><span class="p">()]</span>
    <span class="n">rhs_coefficients</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">coefficients</span><span class="p">[:(</span><span class="n">rhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_coefficients</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">rhs_coefficients</span> <span class="o">+=</span> <span class="p">[</span><span class="n">field</span><span class="p">.</span><span class="n">zero</span><span class="p">()]</span>

    <span class="n">lhs_codeword</span> <span class="o">=</span> <span class="n">ntt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">lhs_coefficients</span><span class="p">)</span>
    <span class="n">rhs_codeword</span> <span class="o">=</span> <span class="n">ntt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rhs_coefficients</span><span class="p">)</span>

    <span class="n">hadamard_product</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">*</span> <span class="n">r</span> <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lhs_codeword</span><span class="p">,</span> <span class="n">rhs_codeword</span><span class="p">)]</span>

    <span class="n">product_coefficients</span> <span class="o">=</span> <span class="n">intt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">hadamard_product</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Polynomial</span><span class="p">(</span><span class="n">product_coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">degree</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
</code></pre></div></div>

<p>Fast multiplication serves as the basis for a bunch of fast polynomial arithmetic algorithms. Of particular interest to this tutorial is the calculation of <em>zerofiers</em> – the polynomials that vanish on a given list of points called the <em>domain</em>. For this task, the divide-and-conquer strategy suggests itself:</p>
<ul>
  <li>divide the domain into two equal parts;</li>
  <li>compute the zerofiers for the two parts separately; and</li>
  <li>multiply the zerofiers using fast multiplication.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fast_zerofier</span><span class="p">(</span> <span class="n">domain</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span> <span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="n">root_order</span> <span class="o">==</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root does not have supplied order"</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="p">(</span><span class="n">root_order</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root is not primitive root of supplied order"</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Polynomial</span><span class="p">([])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Polynomial</span><span class="p">([</span><span class="o">-</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()])</span>

    <span class="n">half</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">left</span> <span class="o">=</span> <span class="n">fast_zerofier</span><span class="p">(</span><span class="n">domain</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">fast_zerofier</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="n">half</span><span class="p">:],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fast_multiply</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>
</code></pre></div></div>

<p>Another task benefiting from fast multiplication (not to mention fast zerofier calculation) is batch evaluation in an arbitrary domain. The idea behind the algorithm is to progressively reduce the given polynomial to a new polynomial that takes the same values on a subset of the domain. The term “reduce” is not a metaphor – it is polynomial reduction modulo the zerofier for that domain. So this gives rise to another divide-and-conquer algorithm:</p>
<ul>
  <li>divide the domain into two halves, left and right;</li>
  <li>compute the zerofier for each half;</li>
  <li>reduce the polynomial modulo left zerofier and modulo right zerofier;</li>
  <li>batch-evaluate left remainder in left domain half and right remainder in right domain;</li>
  <li>concatenate vectors of evaluation.</li>
</ul>

<p>Note that the zerofiers, which are calculated by another divide-and-conquer algorithm, are used in the opposite order to how they are produced. A slightly more complex algorithm makes use of memoization for a performance boost.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fast_evaluate</span><span class="p">(</span> <span class="n">polynomial</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span> <span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="n">root_order</span> <span class="o">==</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root does not have supplied order"</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="p">(</span><span class="n">root_order</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root is not primitive root of supplied order"</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">polynomial</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

    <span class="n">half</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">left_zerofier</span> <span class="o">=</span> <span class="n">fast_zerofier</span><span class="p">(</span><span class="n">domain</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>
    <span class="n">right_zerofier</span> <span class="o">=</span> <span class="n">fast_zerofier</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="n">half</span><span class="p">:],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>

    <span class="n">left</span> <span class="o">=</span> <span class="n">fast_evaluate</span><span class="p">(</span><span class="n">polynomial</span> <span class="o">%</span> <span class="n">left_zerofier</span><span class="p">,</span> <span class="n">domain</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">fast_evaluate</span><span class="p">(</span><span class="n">polynomial</span> <span class="o">%</span> <span class="n">right_zerofier</span><span class="p">,</span> <span class="n">domain</span><span class="p">[</span><span class="n">half</span><span class="p">:],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
</code></pre></div></div>

<p>Let’s now turn to the opposite of evaluation – polynomial interpolation. Ideally, we would like to apply another divide-and-conquer strategy, but it’s tricky. We can divide the set of points into two halves and find the interpolants for each, but then how do we combine them?</p>

<p>How about finding the polynomial that passes through the left half of points, and takes the value 0 in the x-coordinates of the right half, and vice versa? This is certainly progress because adding them will give the desired interpolant. However, this is no longer a divide-and-conquer algorithm because after one recursion step the magnitude of the problem is still the same.</p>

<p>What if we find the interpolant through the left half of points, and multiply it by the zerofier of right half’s x-coordinates? Close, but no cigar: the zerofier will take values different from 1 on the left x-coordinates, meaning that multiplication will destroy the information embedded in the left interpolant.</p>

<p>But the right zerofier’s values in the left x-coordinates are not random, and can be predicted simply by calculating the right zerofier and batch-evaluating it in the left x-coordinates. What needs to be done is to find the polynomial that passes through points whose x-coordinates correspond to the left half of points, and whose y-coordinates anticipate multiplication by the zerofier. These are just the left y-coordinates, divided by values of the right zerofier in the matching x-coordinates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fast_interpolate</span><span class="p">(</span> <span class="n">domain</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span> <span class="p">):</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="n">root_order</span> <span class="o">==</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root does not have supplied order"</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="p">(</span><span class="n">root_order</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root is not primitive root of supplied order"</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)),</span> <span class="s">"cannot interpolate over domain of different length than values list"</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Polynomial</span><span class="p">([])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Polynomial</span><span class="p">([</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="n">half</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">left_zerofier</span> <span class="o">=</span> <span class="n">fast_zerofier</span><span class="p">(</span><span class="n">domain</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>
    <span class="n">right_zerofier</span> <span class="o">=</span> <span class="n">fast_zerofier</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="n">half</span><span class="p">:],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>

    <span class="n">left_offset</span> <span class="o">=</span> <span class="n">fast_evaluate</span><span class="p">(</span><span class="n">right_zerofier</span><span class="p">,</span> <span class="n">domain</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>
    <span class="n">right_offset</span> <span class="o">=</span> <span class="n">fast_evaluate</span><span class="p">(</span><span class="n">left_zerofier</span><span class="p">,</span> <span class="n">domain</span><span class="p">[</span><span class="n">half</span><span class="p">:],</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">v</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">left_offset</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"left_offset:"</span><span class="p">,</span> <span class="s">" "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">left_offset</span><span class="p">))</span>

    <span class="n">left_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="n">d</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">left_offset</span><span class="p">)]</span>
    <span class="n">right_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="n">d</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">half</span><span class="p">:],</span> <span class="n">right_offset</span><span class="p">)]</span>

    <span class="n">left_interpolant</span> <span class="o">=</span> <span class="n">fast_interpolate</span><span class="p">(</span><span class="n">domain</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">left_targets</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>
    <span class="n">right_interpolant</span> <span class="o">=</span> <span class="n">fast_interpolate</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="n">half</span><span class="p">:],</span> <span class="n">right_targets</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">left_interpolant</span> <span class="o">*</span> <span class="n">right_zerofier</span> <span class="o">+</span> <span class="n">right_interpolant</span> <span class="o">*</span> <span class="n">left_zerofier</span>
</code></pre></div></div>

<p>Next up: fast evaluation on a coset. This task is needed in the STARK pipeline when transforming a polynomial into a codeword to be input to FRI. It is possible to solve this problem using fast batch-evaluation on arbitrary domains. However, when the given domain coincides with a coset of order $2^k$, it would be a shame not to use the NTT directly. The only question is how to shift the domain of evaluation. This is precisely what polynomial scaling achieves.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fast_coset_evaluate</span><span class="p">(</span> <span class="n">polynomial</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">order</span> <span class="p">):</span>
    <span class="n">scaled_polynomial</span> <span class="o">=</span> <span class="n">polynomial</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">ntt</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">scaled_polynomial</span><span class="p">.</span><span class="n">coefficients</span> <span class="o">+</span> <span class="p">[</span><span class="n">offset</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">zero</span><span class="p">()]</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">polynomial</span><span class="p">.</span><span class="n">coefficients</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">values</span>
</code></pre></div></div>

<p>Fast evaluation on a coset allows us to answer a pesky problem that arises when adapting the fast multiplication procedure to divide instead of multiply. What happens when the divisor codeword is zero in a given location? If the numerator codeword is not zero in that location, then the division gives a nonzero remainder and the entire operation can be flagged as erroneous. But there can still be clean division if the numerator is also zero in the given location. This is exactly the problem that occurs when attempting to use NTTs to divide out the zerofiers.</p>

<p>The solution is to perform the element-wise division one codewords arising from evaluation on a coset. Specifically, the procedure involves five steps:</p>
<ul>
  <li>scale</li>
  <li>NTT</li>
  <li>element-wise divide</li>
  <li>inverse NTT</li>
  <li>unscale</li>
</ul>

<p>This solution only works if the denominator polynomials does not have any zeros on the coset. However, in some cases (like dividing out zerofiers), the denominator is <em>known</em> not to have zeros on a partcular coset.</p>

<p>The python code has a lot of boilerplate to deal with special circumstances, but in the end it boils down to those five steps.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fast_coset_divide</span><span class="p">(</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">primitive_root</span><span class="p">,</span> <span class="n">root_order</span> <span class="p">):</span> <span class="c1"># clean division only!
</span>    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="n">root_order</span> <span class="o">==</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root does not have supplied order"</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">primitive_root</span><span class="o">^</span><span class="p">(</span><span class="n">root_order</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">primitive_root</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()),</span> <span class="s">"supplied root is not primitive root of supplied order"</span>
    <span class="k">assert</span><span class="p">(</span><span class="ow">not</span> <span class="n">rhs</span><span class="p">.</span><span class="n">is_zero</span><span class="p">()),</span> <span class="s">"cannot divide by zero polynomial"</span>

    <span class="k">if</span> <span class="n">lhs</span><span class="p">.</span><span class="n">is_zero</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">Polynomial</span><span class="p">([])</span>

    <span class="k">assert</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()),</span> <span class="s">"cannot divide by polynomial of larger degree"</span>

    <span class="n">field</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">field</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">primitive_root</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">root_order</span>
    <span class="n">degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">degree</span><span class="p">(),</span><span class="n">rhs</span><span class="p">.</span><span class="n">degree</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lhs</span> <span class="o">/</span> <span class="n">rhs</span>

    <span class="k">while</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="n">order</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">^</span><span class="mi">2</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="n">scaled_lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
    <span class="n">scaled_rhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
    
    <span class="n">lhs_coefficients</span> <span class="o">=</span> <span class="n">scaled_lhs</span><span class="p">.</span><span class="n">coefficients</span><span class="p">[:(</span><span class="n">lhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_coefficients</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">lhs_coefficients</span> <span class="o">+=</span> <span class="p">[</span><span class="n">field</span><span class="p">.</span><span class="n">zero</span><span class="p">()]</span>
    <span class="n">rhs_coefficients</span> <span class="o">=</span> <span class="n">scaled_rhs</span><span class="p">.</span><span class="n">coefficients</span><span class="p">[:(</span><span class="n">rhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs_coefficients</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">rhs_coefficients</span> <span class="o">+=</span> <span class="p">[</span><span class="n">field</span><span class="p">.</span><span class="n">zero</span><span class="p">()]</span>

    <span class="n">lhs_codeword</span> <span class="o">=</span> <span class="n">ntt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">lhs_coefficients</span><span class="p">)</span>
    <span class="n">rhs_codeword</span> <span class="o">=</span> <span class="n">ntt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rhs_coefficients</span><span class="p">)</span>

    <span class="n">quotient_codeword</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">/</span> <span class="n">r</span> <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lhs_codeword</span><span class="p">,</span> <span class="n">rhs_codeword</span><span class="p">)]</span>
    <span class="n">scaled_quotient_coefficients</span> <span class="o">=</span> <span class="n">intt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">quotient_codeword</span><span class="p">)</span>
    <span class="n">scaled_quotient</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">(</span><span class="n">scaled_quotient_coefficients</span><span class="p">[:(</span><span class="n">lhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">scaled_quotient</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="n">offset</span><span class="p">.</span><span class="n">inverse</span><span class="p">())</span>

</code></pre></div></div>

<h2 id="fast-zerofier-evaluation">Fast Zerofier Evaluation</h2>

<p>The STARK trace length must be a power of 2. When this is the case, the composition polynomials will take the value 0 on all but one point of the power-of-two subgroup, and the matching zerofier has the form $\frac{X^{2^k} - 1}{X-1}$, which can be computed quickly by the verifier. If the trace is far from a power of two, say by a difference of $d$, then the verifier needs to evaluate a zerofier that has $d-1$ factors in the denominator. In other words, <em>the trace length must be a power of two in order for the verifier to be fast</em>.</p>

<p>It is tempting to pad the trace until its length is the next power of 2. Clearly this padding must be compatible with the transition constraints so that the composition polynomials still evaluate to zero on all (but one point) of the power-of-two subgroup. The natural solution is to use the apply the same transition function for a power of two number of cycles, and have the boundary conditions refer to the “output” whose cycle index is somewhere in the middle. However, this design decision introduces a problem when it comes to appending randomizers to the trace for the purpose of leaking zero knowledge.</p>
<ul>
  <li>If the randomizers are appended after padding the trace, then the randomized trace does not fit into the power-of-two subgroup. In this case the interpolant must be computed such that:
    <ul>
      <li>over the power-of-two subgroup it evaluates to the execution trace; and</li>
      <li>over a distinct domain it evaluates to the uniformly random randomizers.</li>
    </ul>
  </li>
  <li>If the randomizers are appended before padding, then the transition constraints must by compatible with this operation, or else the composition polynomials will not evaluate to zero in the entire power-of-two subgroup. This option requires changing the AIR.</li>
</ul>

<p>I am not sure which of the options is the standard solution. Both strike me as hacky workarounds for a problem in need of a more elegant solution. Preprocessing offers this solution, obviates padding, and serves a dual didactical purpose particularly relevant for this tutorial.</p>

<h3 id="preprocessing">Preprocessing</h3>

<p>Where a standard Polynomial IOP consists of two parties, the prover and the verifier, a <em>Preprocessing Polynomial IOP</em> consists if three: a prover, a verifier, and an <em>indexer</em>. (The indexer is sometimes also called the <em>preprocessor</em> or the <em>helper</em>.)</p>

<p>The role of the indexer is to perform computations that help the verifier (not to mention prover) but that are too expensive for the verifier to perform directly. The catch is that the indexer does not receive the same input as the verifier does. The indexer’s input (the <em>index</em>) is information about the computation that can be computed ahead of time, before specific data is known. For example, the index could be the number of cycles that the computation is supposed to take, along with the transition constraints. The specific information about the computation, or <em>instance</em>, would be the boundary constraints. The verifier’s input is the instance as well as the indexer’s output (which itself may include the index). The point is that from the verifier’s point of view, the indexer’s output is trusted.</p>

<p><img src="/graphics/preprocessing.svg" alt="Information flow in a proof system with preprocessing." /></p>

<p>Concretely, the indexer’s output to the verifier will be a commitment to the zerofier $Z(X) = \prod_{i=0}^{T-1} (X-\omicron^i)$ via the familiar Merkle root of Reed-Solomon codeword construction. Whenever the verifier needs the value of this zerofier in a point, the prover provides him with this leaf along with an authentication path. Note that the verifier does not need evaluate the zerofier in points outside the FRI domain. As a result, there is no need to prove that the zerofier has a low degree; it comes straight from the trusted indexer.</p>

<h3 id="variable-execution-times">Variable Execution Times</h3>

<p>The solution described above works perfectly fine if the execution time $T$ is known beforehand. What to do, however, when the execution time is not known beforehand, and thus cannot be included in the index?</p>

<p>Preprocessing still holds a solution, but at the cost of a slightly more expensive verifier. The indexer commits to each member of a family of zerofiers ${Z_{2^k}(X)}<em>k$ where $Z</em>{2^k}(X) = \prod_{i=0}^{2^k-1} (X - \omicron^i)$. Let $t = \lfloor \log_2 T \rfloor$ such that $Z_{2^t}(X)$ belongs to this family.</p>

<p>The prover wishes to show that a certain transition polynomial $p(X)$ evaluates to zero on ${\omicron^i}<em>{i=0}^{T-1}$. Without preprocessing, he would commit to and prove the bounded degree of a quotient polynomial $q(X) = p(X) / Z</em>{T-1}(X)$, where $Z_{T-1}(X) = \prod_{i=0}^{T-1} (X - \omicron^i)$. With preprocessing, he must commit to and prove the bounded degree of two quotient polynomials:</p>
<ol>
  <li>$q_l(X) = \frac{p(X) }{ Z_{2^t}(X)}$ and</li>
  <li>$q_r(X) = \frac{p(X) }{\omicron^{T-1-2^t} \cdot Z_{2^t}(\omicron^{2^t-T+1} \cdot X)}$.</li>
</ol>

<p>The denominator of the second polynomial is exactly the zerofier $\prod_{i=T-1-2^t}^{T-1} (X - \omicron^i)$. The transition polynomial is divisible by both zerofiers if and only if it is divisible by the union zerofier $\prod_{i=0}^{T-1} (X - \omicron^i)$.</p>

<p>While this solution works adequately in the general case, for the Rescue-Prime computation, the cycle count is known. Therefore, the implementation reflects this setting.</p>

<h2 id="fast-starks">Fast STARKs</h2>

<p>Now it is time to apply the developed tools to make the STARK algorithmically efficient.</p>

<p>First, add a preprocessing function. This function is a member of the STARK class with access to its fields (such as the number of cycles). It produces two outputs: one for the prover, and one for the prover. In this concrete case, the prover receives the zerofier polynomial and zerofier codeword, and the verifier receives the zerofier Merkle root.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class FastStark:
# [...]
</span>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="n">transition_zerofier</span> <span class="o">=</span> <span class="n">fast_zerofier</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">omicron_domain</span><span class="p">[:(</span><span class="bp">self</span><span class="p">.</span><span class="n">original_trace_length</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="bp">self</span><span class="p">.</span><span class="n">omicron</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">omicron_domain</span><span class="p">))</span>
        <span class="n">transition_zerofier_codeword</span> <span class="o">=</span> <span class="n">fast_coset_evaluate</span><span class="p">(</span><span class="n">transition_zerofier</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">generator</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">fri</span><span class="p">.</span><span class="n">domain_length</span><span class="p">)</span>
        <span class="n">transition_zerofier_root</span> <span class="o">=</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">commit</span><span class="p">(</span><span class="n">transition_zerofier_codeword</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transition_zerofier</span><span class="p">,</span> <span class="n">transition_zerofier_codeword</span><span class="p">,</span> <span class="n">transition_zerofier_root</span>
</code></pre></div></div>

<p>The argument lists of <code class="language-plaintext highlighter-rouge">prove</code> and <code class="language-plaintext highlighter-rouge">verify</code> must be adapted accordingly.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class FastStark:
# [...]
</span>    <span class="k">def</span> <span class="nf">prove</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">transition_constraints</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">transition_zerofier</span><span class="p">,</span> <span class="n">transition_zerofier_codeword</span><span class="p">,</span> <span class="n">proof_stream</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span>
<span class="c1"># [...]
</span>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">proof</span><span class="p">,</span> <span class="n">transition_constraints</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">transition_zerofier_root</span><span class="p">,</span> <span class="n">proof_stream</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span>
</code></pre></div></div>

<p>The prover can use fast coset division to divide out the transition zerofier, and note that this denominator is exactly the argument.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class FastStark:
#     [...]
#     def prove( [..] ):
#       [...]
</span>        <span class="c1"># divide out zerofier
</span>        <span class="n">transition_quotients</span> <span class="o">=</span> <span class="p">[</span><span class="n">fast_coset_divide</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">transition_zerofier</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">generator</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omicron</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omicron_domain_length</span><span class="p">)</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">transition_polynomials</span><span class="p">]</span>
</code></pre></div></div>

<p>The verifier needs to perform this division in a number of locations, which means that he needs the value of the verifier in those locations. Therefore, the prover must provide them, which authentication paths.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class FastStark:
#     [...]
#     def prove( [..] ):
#       [...]
</span>        <span class="c1"># ... and also in the zerofier!
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">quadrupled_indices</span><span class="p">:</span>
            <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">transition_zerofier_codeword</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">Merkle</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">transition_zerofier_codeword</span><span class="p">)</span>
            <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</code></pre></div></div>

<p>The verifier, in turn, needs to read these values and their authentication paths from the proof stream, before verifying the authentication paths and storing the zerofier values in a structure for later use. Note that these authentication paths are verified against the Merkle root, which is the new input to the verifier.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class FastStark:
#     [...]
#     def verify( [..] ):
#       [...]
</span>        <span class="c1"># read and verify transition zerofier leafs
</span>        <span class="n">transition_zerofier</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">duplicated_indices</span><span class="p">:</span>
            <span class="n">transition_zerofier</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">proof_stream</span><span class="p">.</span><span class="n">pull</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">proof_stream</span><span class="p">.</span><span class="n">pull</span><span class="p">()</span>
            <span class="n">verifier_accepts</span> <span class="o">=</span> <span class="n">verifier_accepts</span> <span class="ow">and</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">verify</span><span class="p">(</span><span class="n">transition_zerofier_root</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">transition_zerofier</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">verifier_accepts</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>Then finally, when the nonlinear combination is computed, can these values be read from memory and used.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class FastStark:
#     [...]
#     def verify( [..] ):
#       [...]
</span>                <span class="n">quotient</span> <span class="o">=</span> <span class="n">tcv</span> <span class="o">/</span> <span class="n">transition_zerofier</span><span class="p">[</span><span class="n">current_index</span><span class="p">]</span>
</code></pre></div></div>

<p>At this point what is left is switching to fast polynomial arithmetic outside of the context of preprocessing. The first opportunity is interpolating the trace.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class FastStark:
#     [...]
#     def prove( [..] ):
#         [...]
</span>            <span class="n">trace_polynomials</span> <span class="o">=</span> <span class="n">trace_polynomials</span> <span class="o">+</span> <span class="p">[</span><span class="n">fast_interpolate</span><span class="p">(</span><span class="n">trace_domain</span><span class="p">,</span> <span class="n">single_trace</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omicron</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omicron_domain_length</span><span class="p">)]</span>
</code></pre></div></div>

<p>Next: when committing to the boundary quotients, use fast coset evaluation. Same goes for the randomizer polynomial as well as the combination polynomial.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class FastStark:
#     [...]
#     def prove( [..] ):
</span>        <span class="c1"># [...]
</span>        <span class="c1"># commit to boundary quotients
</span>        <span class="c1"># [...]
</span>        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_registers</span><span class="p">):</span>
            <span class="n">boundary_quotient_codewords</span> <span class="o">=</span> <span class="n">boundary_quotient_codewords</span> <span class="o">+</span> <span class="p">[</span><span class="n">fast_coset_evaluate</span><span class="p">(</span><span class="n">boundary_quotients</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">generator</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">fri_domain_length</span><span class="p">)]</span>
            <span class="n">merkle_root</span> <span class="o">=</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">commit</span><span class="p">(</span><span class="n">boundary_quotient_codewords</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
            <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">merkle_root</span><span class="p">)</span>
        <span class="c1"># [...]
</span>        <span class="c1"># commit to randomizer polynomial
</span>        <span class="n">randomizer_polynomial</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">([</span><span class="bp">self</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">17</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">max_degree</span><span class="p">(</span><span class="n">transition_constraints</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
        <span class="n">randomizer_codeword</span> <span class="o">=</span> <span class="n">fast_coset_evaluate</span><span class="p">(</span><span class="n">randomizer_polynomial</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">generator</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">fri_domain_length</span><span class="p">)</span>
        <span class="n">randomizer_root</span> <span class="o">=</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">commit</span><span class="p">(</span><span class="n">randomizer_codeword</span><span class="p">)</span>
        <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">randomizer_root</span><span class="p">)</span>
        <span class="c1"># [...]
</span>        <span class="c1"># compute matching codeword
</span>        <span class="n">combined_codeword</span> <span class="o">=</span> <span class="n">fast_coset_evaluate</span><span class="p">(</span><span class="n">combination</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">generator</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">fri_domain_length</span><span class="p">)</span>
</code></pre></div></div>

<p>Dividing out the transition zerofier is a pretty intense task. It pays to switch to NTT-based division. Note that coset division is needed here, since the zerofier definitely takes the value zero on points of the trace domain.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1"># divide out zerofier
</span>        <span class="n">transition_quotients</span> <span class="o">=</span> <span class="p">[</span><span class="n">fast_coset_divide</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">transition_zerofier</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">generator</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omicron</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">omicron_domain_length</span><span class="p">)</span> <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">transition_polynomials</span><span class="p">]</span>
</code></pre></div></div>

<p>Lastly, in the FRI verifier, switch out the slow Lagrange interpolation for the much faster (coset) NTT based interpolation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class Fri:
</span>    <span class="c1"># [...]
</span>    <span class="c1"># def verify( [..] ):
</span>        <span class="c1"># [...]
</span>        <span class="c1"># compute interpolant
</span>        <span class="n">last_domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">last_offset</span> <span class="o">*</span> <span class="p">(</span><span class="n">last_omega</span><span class="o">^</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">last_codeword</span><span class="p">))]</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">intt</span><span class="p">(</span><span class="n">last_omega</span><span class="p">,</span> <span class="n">last_codeword</span><span class="p">)</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">(</span><span class="n">coefficients</span><span class="p">).</span><span class="n">scale</span><span class="p">(</span><span class="n">last_offset</span><span class="p">.</span><span class="n">inverse</span><span class="p">())</span>
</code></pre></div></div>

<p>After modifying the Rescue-Prime signature scheme to use the new, <code class="language-plaintext highlighter-rouge">FastStark</code> class and methods, this gives rise to a significantly faster signature scheme.</p>

<ul>
  <li>secret key size: 16 bytes (yay!)</li>
  <li>public key size: 16 bytes (yay!)</li>
  <li>signature size: <strong>~160 kB</strong></li>
  <li>keygen time: 0.01 seconds (acceptable)</li>
  <li>signing time: <strong>72 seconds</strong></li>
  <li>verification time: <strong>8 seconds</strong></li>
</ul>

<p>How’s that for an improvement? The proof is larger because there are many more Merkle paths associated with zerofier leafs, but in exchange proving and verifying is an order of magnitude faster. Of course there is no shortage of further improvements, but those are beyond the scope of this tutorial and left as exercises to the reader.</p>

  </div>

</article>

      </div>
    </main><!-- Parse the Latex divs with Katex-->
<script type="text/javascript">
  $("script[type='math/tex']").replaceWith(
    function(){
      var tex = $(this).text();
      return katex.renderToString(tex, {displayMode: false});
  });
  
  $("script[type='math/tex; mode=display']").replaceWith(
    function(){
      var tex = $(this).text();
      return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
  });
</script>

</body>

</html>
