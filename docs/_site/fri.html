<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Anatomy of a STARK, Part 3: FRI | Anatomy of a STARK</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Anatomy of a STARK, Part 3: FRI" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="STARK tutorial with supporting source code in python." />
<meta property="og:description" content="STARK tutorial with supporting source code in python." />
<link rel="canonical" href="http://localhost:4000/fri.html" />
<meta property="og:url" content="http://localhost:4000/fri.html" />
<meta property="og:site_name" content="Anatomy of a STARK" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Anatomy of a STARK, Part 3: FRI" />
<script type="application/ld+json">
{"description":"STARK tutorial with supporting source code in python.","@type":"WebPage","headline":"Anatomy of a STARK, Part 3: FRI","url":"http://localhost:4000/fri.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Anatomy of a STARK" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Anatomy of a STARK</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/basic-tools.html">Anatomy of a STARK, Part 2: Basic Tools</a><a class="page-link" href="/faster.html">Anatomy of a STARK, Part 6: Speeding Things Up</a><a class="page-link" href="/fri.html">Anatomy of a STARK, Part 3: FRI</a><a class="page-link" href="/introduction.html">Anatomy of a STARK, Part 0: Introduction</a><a class="page-link" href="/overview.html">Anatomy of a STARK, Part 1: STARK Overview</a><a class="page-link" href="/rescue-prime.html">Anatomy of a STARK, Part 5: A Rescue-Prime STARK</a><a class="page-link" href="/stark.html">Anatomy of a STARK, Part 4: The STARK Polynomial IOP</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Anatomy of a STARK, Part 3: FRI</h1>
  </header>

  <div class="post-content">
    <h1 id="anatomy-of-a-stark-part-3-fri">Anatomy of a STARK, Part 3: FRI</h1>

<p>FRI stands for <em>Fast Reed-Solomon IOP of Proximity</em>, where IOP stands for <em>interactive oracle proof</em>. FRI is presented in the language of codewords: the prover sends codewords to the verifier who does not read them whole but who makes oracle-queries to read them in select locations. The codewords in this protocol are <em>Reed-Solomon codewords</em>, meaning that their values correspond to the evaluation of some low-degree polynomial in a list of points called the domain $D$. The length of this list is larger than the number of possibly nonzero coefficients in the polynomial by a factor called the <em>expansion factor</em> (also <em>blowup factor</em>), which is the reciprocal of the code’s <em>rate</em> $\rho$.</p>

<p>Since the codewords represent low-degree polynomials, and since the codewords are hidden behind Merkle trees in any real-world deployment, it is arguably more natural to present FRI from the point of view of a polynomial commitment scheme, with some caveats. While there is scientific merit in separating the type of codewords from the IOP, and those two from the Merkle tree that simulates the oracles, from an accessibility point of view it is beneficial to consider them as three components of one basic primitive that relates to polynomial commitment schemes. For the remainder of this tutorial, we will use the term FRI in this sense.</p>

<p>In a regular polynomial commitment scheme, a prover commits to a polynomial $f(X)$ that is later opens in a given point $z$ such that it cannot equivocate between two different values of $f(z)$. The scheme consists of three algorithms, but with a different description:</p>
<ul>
  <li>$\mathsf{commit}$, which computes a binding commitment from the polynomial;</li>
  <li>$\mathsf{open}$, which produces a proof that $f(z) = y$ for some $z$ and for the polynomial $f(X)$ that matches with the given commitment;</li>
  <li>$\mathsf{verify}$, which verifies the proof produced by $\mathsf{open}$.</li>
</ul>

<p>The FRI scheme has a different interface but a later section shows how it can simulate the standard polynomial commitment scheme interface without much overhead. FRI is a protocol between a prover and a verifier, which establishes that a given codeword belongs to a polynomial of low degree – low meaning at most $\rho$ times the length of the codeword. Without losing much generality<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>, the prover knows this codeword explicitly, whereas the verifier knows only its Merkle root and leafs of his choosing, assuming the successful validation of the authentication paths that establish the leafs’ membership to the Merkle tree.</p>

<h2 id="split-and-fold">Split-and-Fold</h2>

<p>One of the great ideas for proof systems in recent years was <em>split-and-fold</em> technique. The idea is to reduce a claim to two claims of half the size. Then both claims are merged into one using random weights supplied by the verifier. After logarithmically many steps (as a function of the size of the original claim) the claim has been reduced to one of a trivial size which is true if and only if (modulo some negligible security degradation) the original claim was true.</p>

<p>In the case of FRI, this computational claim asserts that the given codeword corresponds to a polynomial of low degree. Specifically, let $N$ be the length of the codeword, and $d$ be the maximum degree of the polynomial that it corresponds<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup> to. Let this polynomial be $f(X) = \sum_{i=0}^{d} c_i X^i$.</p>

<p>Following the divide-and-conquer strategy of the fast Fourier transform, this polynomial is divided into even and odd terms.
\(f(X) = f_E(X^2) + X \cdot f_O(X^2)\)
where
\(f_E(X^2) = \frac{f(X) + f(-X)}{2} = \sum_{i=0}^{\frac{d+1}{2}-1} c_{2i} X^{2i}\)
and
\(f_O(X^2) = \frac{f(X) - f(-X)}{2X} = \sum_{i=0}^{\frac{d+1}{2}-1} c_{2i+1} X^{2i} \enspace .\)
To see that this decomposition is correct, observe that for $f_E(X)$, the odd terms cancel; whereas for $f_O(X)$, it is the even terms that cancel. The key step of the protocol derives a codeword for $f^\star(X) = f_E(X) + \alpha \cdot f_O(X)$ from the codeword for $f(X)$, where $\alpha$ is a random scalar supplied by the verifier.</p>

<p>Let $D$ be a subgroup of even order $N$ of the multiplicative group of the field, and let $\omega$ generate this subgroup: $\langle \omega \rangle = D \subset \mathbb{F}<em>p \backslash{0}$. Let ${f(\omega^i)}</em>{i=0}^{N-1}$ be the codeword for $f(X)$, corresponding with evaluation on $D$. Let $D^\star = \langle \omega^2 \rangle$ be another domain, of half the length, and ${f_E(\omega^{2i})}<em>{i=0}^{N/2-1}$, ${f_O(\omega^{2i})}</em>{i=0}^{N/2-1}$, and ${f^\star(\omega^{2i})}_{i=0}^{N/2-1}$ be the codewords for $f_E(X)$, $f_O(X)$, and $f^\star(X)$, respectively, corresponding to evaluation on $D^\star$.</p>

<p>Expanding the definition of $f^\star(X)$ gives
\(\{f^\star(\omega^{2i})\}_{i=0}^{N/2-1} = \{f_E(\omega^{2i}) + \alpha \cdot f_O(\omega^{2i})\}_{i=0}^{N/2-1} .\)</p>

<p>Expand again, this time with the definition of $f_E(X^2)$ and $f_O(X^2)$.
\(\{f^\star(\omega^{2i})\}_{i=0}^{N/2-1} = \left\{ \frac{f(\omega^i) + f(-\omega^i)}{2} + \alpha \cdot \frac{f(\omega^i) - f(-\omega^i)}{2 \omega^i} \right\}_{i=0}^{N/2-1} \\ = \{ 2^{-1} \cdot \left( ( 1 + \alpha \cdot \omega^{-i} ) \cdot f(\omega^i) + (1 - \alpha \cdot \omega^{-i} ) \cdot f(-\omega^i) \right) \}_{i=0}^{N/2-1}\)</p>

<p>Since the order of $\omega$ is $N$, we have $\omega^{N/2} = -1$, and therefore $f(-\omega^i) = f(\omega^{N/2 + i})$. This substitution makes it clear that even though the index iterates over half the range (from $0$ to $N/2-1$), all the points of ${f(\omega^i)}<em>{i=0}^{N-1}$ are involved in the derivation of ${f^\star(\omega^{2i})}</em>{i=0}^{N/2-1}$. It does not matter that the latter codeword has half the length; its polynomial has half the degree.</p>

<p>At this point it is possible to describe the mechanics for one round of the FRI protocol. The prover commits to $f(X)$ by sending the Merkle root of its codeword to the verifier. The verifier responds with the random challenge $\alpha$. The prover computes $f^\star(X)$ and commits to it by sending the Merkle root of ${f^\star(\omega^{2i})}_{i=0}^{N/2-1}$ to the verifier.</p>

<p>The verifier now has two commitments to polynomials and his task is to verify that their correct relation holds. Specifically, the verifier should reject the proof if $f^\star(X) \neq 2^{-1} \cdot \left( (1 + \alpha X^{-1}) \cdot f(X) + (1 - \alpha X^{-1} ) \cdot f(-X) \right)$. (Ignore the values left and right hand sides take in 0.) To do this, the verifier randomly samples an index $i \xleftarrow{$} {0, \ldots, N/2-1}$, which defines 3 points:</p>
<ul>
  <li>$A: (\omega^i, f(\omega^i))$,</li>
  <li>$B: (\omega^{N/2+i}, f(\omega^{N/2+i}))$,</li>
  <li>$C: (\alpha, f^\star(\omega^{2i}))$.</li>
</ul>

<p>Notice that the x-coordinates of $A$ and $B$ are the square roots of $\omega^{2i}$. Upon receiving the index $i$ from the verifier, the prover provides the y-coordinates along with their Merkle authentication paths. The verifier verifies these paths against their proper roots and follows up by verifying that $A$, $B$, and $C$ fall on a straight line. This test is known as the <em>colinearity check</em>.</p>

<p>Why would $A$, $B$, and $C$ lie on a straight line? Let’s find the line that passes through $A$ and $B$ and see what that means for $C$. An elementary Lagrange interpolation yields
\(y = \sum_i y_i \prod_{j \neq i} \frac{x - x_j}{x_i - x_j} \\
= f(\omega^i) \cdot \frac{x - \omega^{N/2+i}}{\omega^{i} - \omega^{N/2+i}} + f(\omega^{N/2+i}) \cdot \frac{x - \omega^{i}}{\omega^{N/2+i} - \omega^{i}} \\
=  f(\omega^i) \cdot 2^{-1} \cdot \omega^{-i} \cdot (x + \omega^i) - f(\omega^{N/2+i}) \cdot 2^{-1} \cdot \omega^{-i} (x - \omega^i) \\
= 2^{-1} \cdot \left( (1 + x \cdot \omega^{-i}) \cdot f(\omega^i) + (1 - x \cdot \omega^i) \cdot f(\omega^{N/2 + i}) \right) \enspace .\)
By setting $x = \alpha$ we get exactly the y-coordinate of $C$.</p>

<p>This description covers one round, at the end of which the prover and verifier are in the same position as they were at the start. The prover wishes to establish that a given Merkle root decommits to a codeword whose defining polynomial has a bounded degree. There is one important difference though: as a result of running one round of FRI, the length of the codeword as well as the number of possibly nonzero coefficients of the polynomial have halved. Prover and verifier can set $f = f^\star$, $D = d^\star$, and repeat the process. After running $\lceil \log_2 (d+1) \rceil - 1$ rounds of FRI, where $d$ is the degree of the original polynomial, prover and verifier end up with a constant polynomial whose codeword is also constant. At this point, the prover sends this constant<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup> instead of the codeword’s Merkle root, making it abundantly clear that it corresponds to a polynomial of degree $0$.</p>

<p><img src="/graphics/fri-overview.svg" alt="FRI overview" /></p>

<p>In production systems the length of the codeword is often reduced not by a factor 2 but a small power of 2. This optimization reduces the proof size and might even generate running time improvements. However, this tutorial optimizes for simplicity and any further discussion about higher folding factors is out of scope.</p>

<h3 id="index-folding">Index Folding</h3>

<p>The above description glosses over a counter-intuitive point but highly subtle: <em>the random indices are not independent between rounds</em>. Instead, the same index is re-used across all rounds, with reductions modulo the codeword length when necessary.</p>

<p>The reason why sampling the indices independently in each round less insecure, is because it is likely to fail to catch hybrid codewords, as the next picture shows.</p>

<p><img src="/graphics/fri-attack.svg" alt="Sampling indices in FRI. Left: less secure; right: more secure." /></p>

<p>The blue codeword is far from any codeword that matches with a low degree polynomial, whereas the green codeword does correspond to a low degree polynomial. In order to switch from blue to green, the malicious prover uses a hybrid codeword in the second round. This hybrid codeword is obtained by selecting the values from the one codeword or the other based on a randomly chosen partition. The malicious prover succeeds when all colinearity checks involve points of the same color.</p>

<p>The attack is thwarted when the same indices are used. The hybrid codeword necessarily generates a colinearity test of mismatching colors in at least one round.</p>

<h3 id="intuition-for-security">Intuition for Security</h3>

<p>The polynomial $f^\star(X^2)$ is a random linear combination of $f(X)$ and $f(-X)$. Clearly, if the prover is honest, then $f^\star(X)$ and its codeword satisfy this relation. What is less intuitive is when the prover is dishonest in more subtle ways than the hybrid codeword attack – what is it about this colinearity check that makes the verifier likely to notice the fraud?</p>

<p>A fraudulent prover is successful when the verifier accepts a codeword that does not correspond to a low degree polynomial. Let ${f(\omega^i)}_{i=0}^{N-1}$ be such a fraudulent codeword, corresponding to a polynomial $f(X)$ of degree $N-1$. Then $f_E(X)$ and $f_O(X)$ will be of degree at most $N/2 - 1$, and so will their linear combination $f^\star(X) = f_E(X) + \alpha \cdot f_O(X)$. At this point the malicious prover has two options.</p>
<ol>
  <li>He computes the codeword ${f^\star(\omega^{2i})}_{i=0}^{N/2-1}$ honestly by evaluating $f^\star(X)$ on $L^\star = \langle \omega^2 \rangle$. This does not improve his situation because instead of “proving” that a codeword of length $N$ corresponds to a polynomial of degree less than $\rho \cdot N$, he now has to “prove” that this codeword of length $N/2$ corresponds to a polynomial of degree less than $\rho \cdot N/2$. There is no reason to assume this false claim is any easier to prove than the one he started out with.</li>
  <li>He sends a different codeword ${v_i}_{i=0}^{N/2-1}$ that disagrees with $f^\star(X)$ in <em>enough</em> points of $L^\star = \langle \omega^2 \rangle$. This is exactly the type of fraud that is likely to be exposed by the verifier’s colinearity checks.</li>
</ol>

<p>Intuitively, a prover who lies in one location is hardly cheating, because it is a single error in an error-correcting code. The other $N/2-1$ values of the codeword still uniquely identify the codeword’s defining polynomial. A cheating prover needs the fraudulent codeword ${v_i}_{i=0}^{N/2-1}$ to correspond to a polynomial of degree less than $\rho \cdot N/2$, and for that to be the case it needs to agree with this low degree polynomial in many more points than just one. But as the number of points where the malicious prover is being dishonest increases, so too does the probability of this fraud being exposed by the colinearity check.</p>

<h3 id="security-level">Security Level</h3>

<p>How many colinearity checks are needed for a target security level of $\lambda$ bits? That’s the million dollar question.</p>

<p>The <a href="https://eccc.weizmann.ac.il/report/2017/134/revision/1/download/">FRI paper</a>, the <a href="https://sites.math.rutgers.edu/~sk1233/deep-fri.pdf">DEEP-FRI follow-up</a>, and the <a href="https://eprint.iacr.org/2020/654">follow-up to the follow-up</a>, present a sequence of more refined argument relying crucially on the code rate $\rho$. I do not pretend to understand these proofs and will content myself with merely reciting the rule of thumb used in the <a href="https://eprint.iacr.org/2021/582">EthSTARK documentation</a> for conjectural security<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">4</a></sup>:</p>
<ul>
  <li>The hash function used for building Merkle trees needs to have at least $2\lambda$ output bits.</li>
  <li>The field needs to have at least $2^\lambda$ elements. (Note that this refers tot the field used for FRI. In particular, you can switch to an extension field if the base field is not large enough.)</li>
  <li>You get $\log_2 \rho^{-1}$ bits of security for every colinearity check, so setting setting the number of colinearity checks to $s = \lceil \lambda / \log_2 \rho^{-1} \rceil$ achieves $\lambda$ bits of security.</li>
</ul>

<h3 id="coset-fri">Coset-FRI</h3>

<p>The description of the FRI protocol up until now involves codewords defined as the list of values taken by a polynomial of low degree on a given <em>evaluation domain</em> $D$, where $D$ is a subgroup of order $2^k$ spanned by some subgroup generator $\omega$. This leads to problems later on, when linking the FRI together with the STARK machinery. Specifically, the STARK protocol is <em>also</em> defined in terms of Reed-Solomon codewords. It is worthwhile to anticipate the problems that can occur when the points of evaluation concide, by choosing two disjoint sets.</p>

<table>
  <tbody>
    <tr>
      <td>Specifically, let the new evaluation domain by a <em>coset</em> of the subgroup of order $2^k$ defined by some <em>offset</em> $g$ which is not a member of the subgroup $\langle \omega \rangle, \cdot$. Specifically, $D = { g \cdot \omega^i</td>
      <td>i \in \mathbb{Z}}$. The most straightforward choice is to set $g$ to a generator of the entire multiplicative group $\mathbb{F} \backslash {0}, \cdot$. The evaluation domain for the next codeword is given by the set of squares of $D$: $D^\star = {d^2</td>
      <td>d \in D} = {g^2 \cdot \omega^{2i}</td>
      <td>i \in \mathbb{Z}}$.</td>
    </tr>
  </tbody>
</table>

<h2 id="implementation">Implementation</h2>

<p>Let’s implement the algorithms described in a module called <code class="language-plaintext highlighter-rouge">Fri</code>. Aside from logic for the prover and the verifier, it has helper methods to derive the number of rounds and the initial evaluation domain.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">blake2b</span>

<span class="k">class</span> <span class="nc">Fri</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">initial_domain_length</span><span class="p">,</span> <span class="n">expansion_factor</span><span class="p">,</span> <span class="n">num_colinearity_tests</span> <span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">domain_length</span> <span class="o">=</span> <span class="n">initial_domain_length</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">omega</span><span class="p">.</span><span class="n">field</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">expansion_factor</span> <span class="o">=</span> <span class="n">expansion_factor</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num_colinearity_tests</span> <span class="o">=</span> <span class="n">num_colinearity_tests</span>

    <span class="k">def</span> <span class="nf">num_rounds</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="n">codeword_length</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">domain_length</span>
        <span class="n">num_rounds</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">codeword_length</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">expansion_factor</span> <span class="ow">and</span> <span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">num_colinearity_tests</span> <span class="o">&lt;</span> <span class="n">codeword_length</span><span class="p">:</span>
            <span class="n">codeword_length</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="n">num_rounds</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num_rounds</span>

    <span class="k">def</span> <span class="nf">eval_domain</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">omega</span><span class="o">^</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">domain_length</span><span class="p">)]</span>
</code></pre></div></div>

<p>Note that the method to compute the number of rounds terminates the protocol early. Specifically, it terminates as soon as the number of colinearity checks is more than one quarter the length of the working codeword. If there were another step, more than half the points in the codeword would be a $C$ point in some colinearity test. At this point, the entropy of a random selection of indices drops significantly.</p>

<h3 id="prove">Prove</h3>

<p>The FRI protocol consists of two phases, called <em>commit</em> and <em>query</em>. In the commit phase, the prover sends Merkle roots of codewords to the verifier, and the verifier supplies random field elements as input to the split-and-fold procedure. In the query phase, the verifier selects indices of leafs, which the prover then opens, so that the verifier can check the colinearity requirement.</p>

<p>It is important to keep track of the set of indices of leafs of the initial codeword that the verifier wants to inspect. This is the point where the FRI protocol links into the Polynomial IOP that comes before it. Specifically, the larger protocol that uses FRI as a subroutine needs to verify that the leafs of the initial Merkle opened by the FRI protocol actually correspond to the codeword that the FRI protocol is supposedly about.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">prove</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">codeword</span><span class="p">,</span> <span class="n">proof_stream</span> <span class="p">):</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">domain_length</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">codeword</span><span class="p">)),</span> <span class="s">"initial codeword length does not match length of initial codeword"</span>

        <span class="c1"># commit phase
</span>        <span class="n">codewords</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">commit</span><span class="p">(</span><span class="n">codeword</span><span class="p">,</span> <span class="n">proof_stream</span><span class="p">)</span>

        <span class="c1"># get indices
</span>        <span class="n">top_level_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">sample_indices</span><span class="p">(</span><span class="n">proof_stream</span><span class="p">.</span><span class="n">prover_fiat_shamir</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">codewords</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">codewords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_colinearity_tests</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">top_level_indices</span><span class="p">]</span>

        <span class="c1"># query phase
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codewords</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codewords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span> <span class="c1"># fold
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">codewords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">codewords</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">indices</span><span class="p">,</span> <span class="n">proof_stream</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">top_level_indices</span>
</code></pre></div></div>

<p>The commit phase consists of several rounds in which:</p>
<ul>
  <li>The Merkle root of the working codeword is computed.</li>
  <li>The Merkle root is sent to the verifier.</li>
  <li>The verifier supplies a random challenge $\alpha$.</li>
  <li>The prover applies the split-and-fold formula to derive a codeword for the next round.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>The prover squares both the offset $g$ and generator $\omega$ such that ${g \cdot \omega^i</td>
          <td>i \in \mathbb{Z}}$ always corresponds to the working codeword’s evaluation domain.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p>After running the loop, the prover is left with a codeword. It sends this codeword to the verifier in the clear. Lastly, the prover needs to keep track of the codewords computed in every round in order to open the Merkle trees generated from them in the next phase.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">codeword</span><span class="p">,</span> <span class="n">proof_stream</span><span class="p">,</span> <span class="n">round_index</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="n">one</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">one</span><span class="p">()</span>
        <span class="n">two</span> <span class="o">=</span> <span class="n">FieldElement</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">field</span><span class="p">)</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">omega</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">offset</span>
        <span class="n">codewords</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># for each round
</span>        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_rounds</span><span class="p">()):</span>

            <span class="c1"># compute and send Merkle root
</span>            <span class="n">root</span> <span class="o">=</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">commit</span><span class="p">(</span><span class="n">codeword</span><span class="p">)</span>
            <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

            <span class="c1"># prepare next round, if necessary
</span>            <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_rounds</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># get challenge
</span>            <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">proof_stream</span><span class="p">.</span><span class="n">prover_fiat_shamir</span><span class="p">())</span>

            <span class="c1"># collect codeword
</span>            <span class="n">codewords</span> <span class="o">+=</span> <span class="p">[</span><span class="n">codeword</span><span class="p">]</span>

            <span class="c1"># split and fold
</span>            <span class="n">codeword</span> <span class="o">=</span> <span class="p">[</span><span class="n">two</span><span class="p">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">one</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="n">omega</span><span class="o">^</span><span class="n">i</span><span class="p">))</span> <span class="p">)</span> <span class="o">*</span> <span class="n">codeword</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">one</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="n">omega</span><span class="o">^</span><span class="n">i</span><span class="p">))</span> <span class="p">)</span> <span class="o">*</span> <span class="n">codeword</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">codeword</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codeword</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span><span class="o">^</span><span class="mi">2</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">^</span><span class="mi">2</span>

        <span class="c1"># send last codeword
</span>        <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">codeword</span><span class="p">)</span>

        <span class="c1"># collect last codeword too
</span>        <span class="n">codewords</span> <span class="o">=</span> <span class="n">codewords</span> <span class="o">+</span> <span class="p">[</span><span class="n">codeword</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">codewords</span>
</code></pre></div></div>

<p>The commit phase consists of the same number of iterations of a different loop:</p>
<ul>
  <li>The indices for the x-coordinates of the $A$ and $B$ points are derived from the set of indices for the x-coordinates of $C$ points.</li>
  <li>The indicated codeword values are sent to the verifier, along with their authentication paths.</li>
</ul>

<p>The prover needs to record the indices of the first round.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">current_codeword</span><span class="p">,</span> <span class="n">next_codeword</span><span class="p">,</span> <span class="n">c_indices</span><span class="p">,</span> <span class="n">proof_stream</span> <span class="p">):</span>
        <span class="c1"># infer a and b indices
</span>        <span class="n">a_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">c_indices</span><span class="p">]</span>
        <span class="n">b_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_codeword</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">c_indices</span><span class="p">]</span>

        <span class="c1"># reveal leafs
</span>        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_colinearity_tests</span><span class="p">):</span>
            <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">((</span><span class="n">current_codeword</span><span class="p">[</span><span class="n">a_indices</span><span class="p">[</span><span class="n">s</span><span class="p">]],</span> <span class="n">current_codeword</span><span class="p">[</span><span class="n">b_indices</span><span class="p">[</span><span class="n">s</span><span class="p">]],</span> <span class="n">next_codeword</span><span class="p">[</span><span class="n">c_indices</span><span class="p">[</span><span class="n">s</span><span class="p">]]))</span>

        <span class="c1"># reveal authentication paths
</span>        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_colinearity_tests</span><span class="p">):</span>
            <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Merkle</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">a_indices</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">current_codeword</span><span class="p">))</span>
            <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Merkle</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">b_indices</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">current_codeword</span><span class="p">))</span>
            <span class="n">proof_stream</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Merkle</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">c_indices</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">next_codeword</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">a_indices</span> <span class="o">+</span> <span class="n">b_indices</span>
</code></pre></div></div>

<p>In the above snippet, the sampling of indices is hidden away behind the argument <code class="language-plaintext highlighter-rouge">c_indices</code>. The wrapper function <code class="language-plaintext highlighter-rouge">prove</code> samples invokes the function <code class="language-plaintext highlighter-rouge">sample_indices</code> to sample the set of master indices. This method takes a seed, a list size, and a desired number, and generates that number of uniformly pseudorandom indices in the given interval. The actual logic is tricky. It involves repeatedly sampling a single index by calling <code class="language-plaintext highlighter-rouge">blake2b</code> on the seed appended with an increasing counter. The function keeps track of indices that are fully folded, <em>i.e.</em>, indicate locations in the last codeword. Sampled indices that generate a collision through folding are rejected.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">sample_index</span><span class="p">(</span> <span class="n">byte_array</span><span class="p">,</span> <span class="n">size</span> <span class="p">):</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">byte_array</span><span class="p">:</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="p">(</span><span class="n">acc</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">acc</span> <span class="o">%</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">sample_indices</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">reduced_size</span><span class="p">,</span> <span class="n">number</span> <span class="p">):</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="n">reduced_size</span><span class="p">),</span> <span class="s">f"cannot sample more indices than available in last codeword; requested: </span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s">, available: </span><span class="si">{</span><span class="n">reduced_size</span><span class="si">}</span><span class="s">"</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">reduced_size</span><span class="p">),</span> <span class="s">"not enough entropy in indices wrt last codeword"</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reduced_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">number</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">Fri</span><span class="p">.</span><span class="n">sample_index</span><span class="p">(</span><span class="n">blake2b</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">counter</span><span class="p">)).</span><span class="n">digest</span><span class="p">(),</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">reduced_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">%</span> <span class="n">reduced_size</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">reduced_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reduced_indices</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">reduced_indices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">reduced_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">indices</span>
</code></pre></div></div>

<h3 id="verify">Verify</h3>

<p>The verifier runs through the same checklist as the prover but runs the dual steps to his. Specifically, the verifier:</p>
<ul>
  <li>reads the Merkle roots from the proof stream and reproduces the random scalars $\alpha$ with Fiat-Shamir;</li>
  <li>reads the last codewords from the proof stream and checks that it matches with a low degree polynomial as well as the last Merkle root to be sent;</li>
  <li>reproduces the master list of random indices with Fiat-Shamir, and infers the remaining indices for the colinearity checks;</li>
  <li>reads the Merkle leafs and their authentication paths from the proof stream, and verifies their authenticity against the indices;</li>
  <li>runs the colinearity checks for every pair of consecutive codewords.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">proof_stream</span><span class="p">,</span> <span class="n">polynomial_values</span> <span class="p">):</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">omega</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">offset</span>

        <span class="c1"># extract all roots and alphas
</span>        <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_rounds</span><span class="p">()):</span>
            <span class="n">roots</span> <span class="o">+=</span> <span class="p">[</span><span class="n">proof_stream</span><span class="p">.</span><span class="n">pull</span><span class="p">()]</span>
            <span class="n">alphas</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">field</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">proof_stream</span><span class="p">.</span><span class="n">verifier_fiat_shamir</span><span class="p">())]</span>

        <span class="c1"># extract last codeword
</span>        <span class="n">last_codeword</span> <span class="o">=</span> <span class="n">proof_stream</span><span class="p">.</span><span class="n">pull</span><span class="p">()</span>

        <span class="c1"># check if it matches the given root
</span>        <span class="k">if</span> <span class="n">roots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">commit</span><span class="p">(</span><span class="n">last_codeword</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"last codeword is not well formed"</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># check if it is low degree
</span>        <span class="n">degree</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">last_codeword</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="p">.</span><span class="n">expansion_factor</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">last_omega</span> <span class="o">=</span> <span class="n">omega</span>
        <span class="n">last_offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_rounds</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">last_omega</span> <span class="o">=</span> <span class="n">last_omega</span><span class="o">^</span><span class="mi">2</span>
            <span class="n">last_offset</span> <span class="o">=</span> <span class="n">last_offset</span><span class="o">^</span><span class="mi">2</span>

        <span class="c1"># assert that last_omega has the right order
</span>        <span class="k">assert</span><span class="p">(</span><span class="n">last_omega</span><span class="p">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">==</span> <span class="n">last_omega</span><span class="o">^</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">last_codeword</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="s">"omega does not have right order"</span>

        <span class="c1"># compute interpolant
</span>        <span class="n">last_domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">last_offset</span> <span class="o">*</span> <span class="p">(</span><span class="n">last_omega</span><span class="o">^</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">last_codeword</span><span class="p">))]</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">Polynomial</span><span class="p">.</span><span class="n">interpolate_domain</span><span class="p">(</span><span class="n">last_domain</span><span class="p">,</span> <span class="n">last_codeword</span><span class="p">)</span>

        <span class="k">assert</span><span class="p">(</span><span class="n">poly</span><span class="p">.</span><span class="n">evaluate_domain</span><span class="p">(</span><span class="n">last_domain</span><span class="p">)</span> <span class="o">==</span> <span class="n">last_codeword</span><span class="p">),</span> <span class="s">"re-evaluated codeword does not match original!"</span>
        
        <span class="k">if</span> <span class="n">poly</span><span class="p">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">degree</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"last codeword does not correspond to polynomial of low enough degree"</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"observed degree:"</span><span class="p">,</span> <span class="n">poly</span><span class="p">.</span><span class="n">degree</span><span class="p">())</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"but should be:"</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># get indices
</span>        <span class="n">top_level_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">sample_indices</span><span class="p">(</span><span class="n">proof_stream</span><span class="p">.</span><span class="n">verifier_fiat_shamir</span><span class="p">(),</span> <span class="bp">self</span><span class="p">.</span><span class="n">domain_length</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">domain_length</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_rounds</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_colinearity_tests</span><span class="p">)</span>

        <span class="c1"># for every round, check consistency of subsequent layers
</span>        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_rounds</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="c1"># fold c indices
</span>            <span class="n">c_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">domain_length</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">top_level_indices</span><span class="p">]</span>

            <span class="c1"># infer a and b indices
</span>            <span class="n">a_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">c_indices</span><span class="p">]</span>
            <span class="n">b_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">domain_length</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">a_indices</span><span class="p">]</span>

            <span class="c1"># read values and check colinearity
</span>            <span class="n">aa</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bb</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_colinearity_tests</span><span class="p">):</span>
                <span class="p">(</span><span class="n">ay</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span> <span class="o">=</span> <span class="n">proof_stream</span><span class="p">.</span><span class="n">pull</span><span class="p">()</span>
                <span class="n">aa</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ay</span><span class="p">]</span>
                <span class="n">bb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">by</span><span class="p">]</span>
                <span class="n">cc</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cy</span><span class="p">]</span>

                <span class="c1"># record top-layer values for later verification
</span>                <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">polynomial_values</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">a_indices</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">ay</span><span class="p">),</span> <span class="p">(</span><span class="n">b_indices</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">by</span><span class="p">)]</span>
                
                <span class="c1"># colinearity check
</span>                <span class="n">ax</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="n">omega</span><span class="o">^</span><span class="n">a_indices</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                <span class="n">bx</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="n">omega</span><span class="o">^</span><span class="n">b_indices</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
                <span class="n">cx</span> <span class="o">=</span> <span class="n">alphas</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">test_colinearity</span><span class="p">([(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ay</span><span class="p">),</span> <span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">),</span> <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">)])</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"colinearity check failure"</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">False</span>

            <span class="c1"># verify authentication paths
</span>            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">num_colinearity_tests</span><span class="p">):</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">proof_stream</span><span class="p">.</span><span class="n">pull</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">verify</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">a_indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">path</span><span class="p">,</span> <span class="n">aa</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"merkle authentication path verification fails for aa"</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">proof_stream</span><span class="p">.</span><span class="n">pull</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">verify</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">b_indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">path</span><span class="p">,</span> <span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"merkle authentication path verification fails for bb"</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">proof_stream</span><span class="p">.</span><span class="n">pull</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">Merkle</span><span class="p">.</span><span class="n">verify</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">c_indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">path</span><span class="p">,</span> <span class="n">cc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">"merkle authentication path verification fails for cc"</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">False</span>

            <span class="c1"># square omega and offset to prepare for next round
</span>            <span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span><span class="o">^</span><span class="mi">2</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">^</span><span class="mi">2</span>

        <span class="c1"># all checks passed
</span>        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h2 id="simulating-a-polynomial-commitment-scheme">Simulating a Polynomial Commitment Scheme</h2>

<p>FRI establishes that a given Merkle root decommits to a polynomial of degree less than $2^k$. The Merkle root can double as the commitment of a polynomial commitment scheme, but how to realize the $\mathsf{open}$ and $\mathsf{verify}$ procedures? Two steps achieve this transformation.</p>

<p><strong>One:</strong> arbitrary degree bounds. If the prover instead wants to prove that a committed polynomial has degree at most $d$, where $d+1$ is not a power of two, can he use FRI? The answer is yes!</p>

<p>Let $f(X)$ be a polynomial of degree at most $d$. Let $g(X)$ be another polynomial defined as \(g(X) = f(X) + X^{2^k - d - 1} \cdot f(X) \enspace ,\)
where $2^k &gt; d+1$. Then $g(X)$ has degree less than $2^k$ only if $f(X)$ has degree at most $d$. So the prover who uses FRI to establish that $g(X)$ has degree less than $2^k$ automatically establishes that $f(X)$ has degree at most $d$.</p>

<p>In order to link the Merkle root for $g(X)$ to the Merkle root for $f(X)$, the verifier supplies a bunch (about $\lambda$) of random indices $i$ and the prover responds with the leafs at those indices and their authentication paths. The verifier then verifies that for every such point $x_i$ being the $i$th point of the evaluation domain, $g(x_i) = (1+x_i^{2^k - d - 1}) \cdot f(x_i)$. Alternatively, the first codeword in FRI can omitted altogether; in this case the verifier relates the second FRI codeword $g^\star(X)$ to $f(X)$ by eliminating the values of $g(X)$ using the same formula.</p>

<p><strong>Two:</strong> dividing out the zerofier. The verifier asks for the value of a committed polynomial $f(X)$ in a given point $z$. The prover responds: $f(z) = y$. Can he authenticate this response? Once again, the answer is yes!</p>

<p>Let $f(X)$ be a polynomial of degree at most $d$, and let $y$ be the purported value of $f(X)$ at $X=z$. Then the polynomial $f(X) - y$ has a zero in $X=z$. Evaluating in $X=z$ is equivalent to modular reduction by $X-z$, so we can write $f(X)-y \equiv 0 \mod X-z$. This implies that $X-z$ divides $f(X)-y$. However, if $f(z) \neq y$, then $X-z$ does not divide $f(X)-y$.</p>

<p>This is useful for FRI because the codeword for $f(X)$ corresponds to a low degree polynomial. Furthermore, the verifier who inspects this codeword in a given point $x$ can compute the value of $\frac{f(X) - y}{X-z}$, giving rise to a new codeword. This derived codeword corresponds to a low degree polynomial if and only if $f(z) = y$. So the prover who lies about $y = f(z)$ will be exposed when trying to use FRI to “prove” that $\frac{f(X) - y}{X-z}$ has degree at most $d-1$.</p>

<p>This process can be repeated any number of times. Suppose the verifier asks for the values of $f(X)$ in $z_0, \ldots, z_{n-1}$. The prover responds with $y_0, \ldots, y_n$, supposedly the values of $f(X)$ in these points. Let $p(X)$ be the polynomial of minimal degree that interpolates between $(z_0, y_0), \ldots, (z_{n-1}, y_{n-1})$. Then $f(X) - p(X)$ has zeros at $X \in {z_0, \ldots, z_{n-1}}$, and so $\prod_{i=0}^{n-1} X - z_i$ divides $f(X) - p(X)$. The verifier who authenticates a Merkle leaf of the tree associated with $f(X)$ can compute the matching value of $\frac{f(X) - p(X)}{\prod_{i=0}^{n-1} X-z_i}$. FRI will establish that this codeword corresponds to a polynomial of degree at most $d-n$ if and only if the prover was honest about all the values of $f(X)$.</p>

<p>So where’s the code implementing this logic? Other Polynomial IOPs do rely on the verifier asking for the values of committed polynomials in arbitrary points, but it turns out that the STARK Polynomial IOP does not. Nevertheless, it does implicitly rely on much of the same logic as was described here.</p>

<h2 id="compiling-a-polynomial-iop">Compiling a Polynomial IOP</h2>

<p>The previous section explains how to use FRI to establish that committed polynomials a) satisfy arbitrary degree bounds; and b) satisfy point-value relations. In any non-trivial Polynomial IOP, STARKs included, there will be many polynomials for which these constraints are being claimed to hold. Since FRI is a comparatively expensive protocol, it pays to <em>batch all invocations into one</em>.</p>

<p>Suppose the prover wants to establish that the Merkle root commitments for $f_0(X), \ldots, f_{n-1}(X)$ represent polynomials of degrees bounded by $d_0, \ldots, d_{n-1}$. To establish this using one FRI claim, the prover and verifier first calculate a <em>weighted nonlinear sum</em>:
\(g(X) = \sum_{i=0}^{n-1} \alpha_i \cdot f_i(X) + \beta_i \cdot X^{2^k-d_i-1} \cdot f_i(X) \enspace .\)
The coefficients $\alpha_i$ and $\beta_i$ are drawn at random and supplied by the verifier. FRI is used once to establish that $g(X)$ has degree less than $2^k \geq \max_i d_i$.</p>

<p>The first Merkle root of the FRI protocol decommits to the codeword associated with $g(X)$. To relate this codeword to the right hand side of the above formula, the verifier can verify the random nonlinear combination in a bunch (say, $\lambda$) of randomly points $x_i$ belonging to the evaluation domain. Alternatively, this Merkle root can be omitted entirely. In this case the verifier directly relates the second FRI codeword associated with $g^\star(X)$ to the random nonlinear combination in the indicated points.</p>

<p>The intuition why this random nonlinear combination trick is secure is as follows. If all the polynomials $f_i(X)$ satisfy their proper degree bounds, then clearly $g(X)$ has degree less than $2^k$ and the FRI protocol succeeds. However, if any one $f_i(X)$ has degree larger than $d_i$, then with overwhelming probability over the randomly chosen $\alpha_i$ and $\beta_i$, the degree of $g(X)$ will be larger than or equal to $2^k$. As a result, FRI will fail.</p>

<p>The astute reader notices that the above random nonlinear combination is similar to the deterministic nonlinear combination in step one of simulating a polynomial commitment scheme. The difference is the absence of random weights in that formula. As a matter of fact, the formula
\(g(X) = f(X) + X^{2^k - d-1} \cdot f(X)\)
captures the right intuition but is concretely insecure. The reason is that when evaluation is restricted to $\mathbb{F}_p$, polynomials behave identical to their representatives modulo $X^p - X$. And so the right summand in the above expression can contain terms that are cancelled by the left when evaluated on a subset of $\mathbb{F}_p$ for the purpose of computing the polynomial’s codeword. As a result, the codeword might correspond to a polynomial of low degree even though $f(X)$ has a <em>very</em> high degree!</p>

<p>The involvement of random coefficients $\alpha$ and $\beta$ supplied by the verifier makes this combination secure:</p>

\[g(X) = \alpha \cdot f(X) + \beta \cdot X^{2^k - d-1} \cdot f(X)\]

<p>When the random coefficients are present, the cancellation of high degree terms occurs with negligible probability.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>The generality lost in this description has to do with when the codeword in question is compiled on the fly from applying arithmetic operations to other codewords. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>The term “corresponds” is used informally here in a manner that hides allowance for error-correcting codewords to disagree from their generating polynomial slightly. FRI makes no distinction between codewords that agree exactly with a low degree polynomials on the given domain, and polynomials that are merely close to such codewords in terms of Hamming distance. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>It might make sense to terminate the protocol early, in which case the prover must send a non-trivial codeword in the clear and the verifier must verify that it has a defining polynomial of bounded degree. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>The <a href="https://eprint.iacr.org/2021/582.pdf">EthSTARK documentation</a> also provides a significantly more complex formula for the security level provably achieved without relying on coding theoretic conjectures. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

</article>

      </div>
    </main><!-- Parse the Latex divs with Katex-->
<script type="text/javascript">
  $("script[type='math/tex']").replaceWith(
    function(){
      var tex = $(this).text();
      return katex.renderToString(tex, {displayMode: false});
  });
  
  $("script[type='math/tex; mode=display']").replaceWith(
    function(){
      var tex = $(this).text();
      return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
  });
</script>

</body>

</html>
