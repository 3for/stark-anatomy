<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Anatomy of a STARK, Part 1: STARK Overview | Anatomy of a STARK</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Anatomy of a STARK, Part 1: STARK Overview" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="STARK tutorial with supporting source code in python." />
<meta property="og:description" content="STARK tutorial with supporting source code in python." />
<link rel="canonical" href="http://localhost:4000/overview.html" />
<meta property="og:url" content="http://localhost:4000/overview.html" />
<meta property="og:site_name" content="Anatomy of a STARK" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Anatomy of a STARK, Part 1: STARK Overview" />
<script type="application/ld+json">
{"description":"STARK tutorial with supporting source code in python.","@type":"WebPage","headline":"Anatomy of a STARK, Part 1: STARK Overview","url":"http://localhost:4000/overview.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Anatomy of a STARK" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Anatomy of a STARK</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/basic-tools.html">Anatomy of a STARK, Part 2: Basic Tools</a><a class="page-link" href="/faster.html">Anatomy of a STARK, Part 6: Speeding Things Up</a><a class="page-link" href="/fri.html">Anatomy of a STARK, Part 3: FRI</a><a class="page-link" href="/introduction.html">Anatomy of a STARK, Part 0: Introduction</a><a class="page-link" href="/overview.html">Anatomy of a STARK, Part 1: STARK Overview</a><a class="page-link" href="/rescue-prime.html">Anatomy of a STARK, Part 5: A Rescue-Prime STARK</a><a class="page-link" href="/stark.html">Anatomy of a STARK, Part 4: The STARK Polynomial IOP</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Anatomy of a STARK, Part 1: STARK Overview</h1>
  </header>

  <div class="post-content">
    <h1 id="anatomy-of-a-stark-part-1-stark-overview">Anatomy of a STARK, Part 1: STARK Overview</h1>

<p>In the terminology of this tutorial, a STARK is a particular SNARK where</p>
<ul>
  <li>hash functions are the only cryptographic ingredient,</li>
  <li>arithmetization is based on AIR (algebraic intermediate representation <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>), and reduces the claim about computational integrity to one about the low degree of certain polynomials</li>
  <li>the low degree of polynomials is proven by using FRI as a subprotocol, and FRI itself is instantiated with Merkle trees <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup>;</li>
  <li>zero-knowledge is optional.</li>
</ul>

<p>This part of the tutorial is about explaining the key terms in this definition of STARKs.</p>

<p>## Interactive Proof Systems</p>

<p>In computational complexity theory, an interactive proof system is a protocol between at least two parties in which one party, the verifier, is convinced of the correctness of a certain mathematical claim if and only if that claim is true. In theory, the claim could be anything expressible by mathematical symbols, such as the Birch and Swinnerton-Dyer conjecture, $\mathbf{P} \neq \mathbf{NP}$, or “the fifteenth Fibonacci number is 643617.” (In a sound proof system, the verifier will reject that last claim.)</p>

<p>A cryptographic proof system turns this abstract notion of interactive proof systems into a concrete object intended for deployment in the real world. This restriction to real world applications induces a couple of simplifications:</p>
<ul>
  <li>The claim is not about a mathematical conjecture but concerns the integrity of a particular computation, like “circuit $C$ gives output $y$ when evaluated on input $x$”, or “Turing machine $M$ outputs $y$ after $T$ steps”. The proof system is said to establish <em>computational integrity</em>.</li>
  <li>There are two parties to the protocol, the prover and the verifier. Without loss of generality the messages sent by the verifier to the prover consist of unadulterated randomness and in this case (so: almost always) the proof system can be made non-interactive with the <em>Fiat-Shamir transform</em>. Non-interactive proof systems consist of a single message from the prover to the verifier.</li>
  <li>Instead of perfect security, it is acceptable for the verifier to have a nonzero but negligibly small false positive or false negative rate. Alternatively, it is acceptable for the proof system to offer security only against provers whose computational power is bounded. After all, all computers are computationally bounded in practice. Sometimes authors use the term <em>argument system</em> to distinguish the protocol from a proof system that offers security against computationally unbounded provers, and <em>argument</em> for the transcript resulting from the non-interactivity transform.</li>
  <li>There has to be a compelling reason why the verifier cannot naïvely re-run the computation whose integrity is asserted by the computational integrity claim. This is because the prover has access to resources that the verifier does not have access to.
    <ul>
      <li>When the restricted resource is time, the verifier should run an order of magnitude faster than a naïve re-execution of the program. Proof systems that achieve this are said to be <em>succinct</em> or have <em>succinct verification</em>.</li>
      <li>Succinct verification requires short proofs, but some proof systems like <a href="https://eprint.iacr.org/2017/1066.pdf">Bulletproofs</a> or <a href="https://eprint.iacr.org/2018/828.pdf">Aurora</a> feature compact proofs but still have slow verifiers.</li>
      <li>When the verifier has no access to secret information that is available to the prover, and when the proof system protects the confidentiality of this secret, the proof system satisfies <em>zero-knowledge</em>. The verifier is convinced of the truth of a computational claim while learning no information about some or all of the inputs to that computation.</li>
    </ul>
  </li>
  <li>Especially in the context of zero-knowledge proof systems, the computational integrity claim may need a subtle amendment. In some contexts it is not enough to prove the correctness of a claim, but the prover must additionally prove that he <em>knows</em> the secret additional input, and could as well have outputted the secret directly instead of producing the proof. Proof systems that achieve this stronger notion of soundness called knowledge-soundness are called <em>proofs (or arguments) of knowledge</em>.</li>
</ul>

<p>A SNARK is a <em>Succinct Non-interactive ARgument of Knowledge</em>. The <a href="https://eprint.iacr.org/2011/443.pdf">paper</a> that coined the term SNARK used <em>succinct</em> to denote proof system with efficient verifiers. However, in recent years the meaning of the term has been diluted to include any system whose proofs are compact. This tutorial takes the side of the original definition.</p>

<h2 id="stark-overview">STARK Overview</h2>

<p>The acronym STARK stands for Scalable Transparent ARgument of Knowledge. <em>Scalable</em> refers to the fact that the prover has a running time that is at most quasilinear in the size of the computation, in contrast to SNARKs where the prover is allowed to have a prohibitively expensive complexity. <em>Transparent</em> refers to the fact that no trusted setup procedure is needed to instantiate the proof system, and hence there is no cryptographic toxic waste. The acronym’s denotation suggests that STARKs are a subclass of SNARKs, and indeed they are, but the term is generally used to refer to a specific construction for scalable transparent SNARKs.</p>

<p>The particular qualities of this construction are best illustrated in the context of the compilation pipeline. Depending on the level of granularity, one might opt to subdivide this process into more or fewer steps. For the purpose of introducing STARKs, the compilation pipeline is divided into four stages and three transformations. Later on in this tutorial there will be a much more fine-grained pipeline and diagram.</p>

<p><img src="graphics/pipeline.svg" alt="The compilation pipeline is divisible into three transformation and four stages." title="Overview of the compilation pipeline for SNARKs" /></p>

<h3 id="computation">Computation</h3>
<p>The input to the entire pipeline is a <em>computation</em>, which you can think of as a program, an input, and an output. All three are provided in a machine-friendly format, such as a list of bytes. In general, the program consists of instructions that determine how a machine manipulates its resources. If the right list of instructions can simulate an arbitrary Turing machine, then the machine architecture is Turing-complete.</p>

<p>In this tutorial the program is hardcoded into the machine architecture. As a result, the space of allowable computations is rather limited. Nevertheless, the inputs and outputs remain variable.</p>

<p>The <em>resources</em> that a computation requires could be <em>time</em>, <em>memory</em>, <em>randomness</em>, <em>secret information</em>, <em>parallelism</em>. The goal is to transform the computation into a format that enables resource-constrained verifier to verify its integrity. It is possible to study more types of resources still, such as entangled qubits, non-determinism, or oracles that compute a given black box function, but the resulting questions are typically the subject of computational complexity theory rather than cryptographical practice.</p>

<h3 id="arithmetization-and-arithmetic-constraint-system">Arithmetization and Arithmetic Constraint System</h3>
<p>The first transformation in the pipeline is known as <em>arithmetization</em>. In this procedure, the sequence of elementary logical and arithmetical operations on strings of bits is transformed into a sequence of native finite field operations on finite field elements, such that the two represent the same computation. The output is an arithmetic constraint system, essentially a bunch of equations with coefficients and variables taking values from the finite field. The computation is integral <em>if and only if</em> the constraint system has a satisfying solution – meaning, a single assignment to the variables such that all the equations hold.</p>

<p>The STARK proof system arithmetizes a computation as follows. At any point in time, the state of the computation is contained in a tuple of $\mathsf{w}$ registers that take values from the finite field $\mathbb{F}$. The machine defines a <em>state transition function</em> $f : \mathbb{F}^\mathsf{w} \rightarrow \mathbb{F}^\mathsf{w}$ that updates the state every cycle. The <em>algebraic execution trace (AET)</em> is the list of all state tuples in chronological order.</p>

<p>The arithmetic constraint system defines at least two types of constraints on the algebraic execution trace:</p>

<ul>
  <li><em>Boundary constraints</em>: at the start or at the end of the computation an indicated register has a given value.</li>
  <li><em>Transition constraints</em>: any two consecutive state tuples evolved in accordance with the state transition function.</li>
</ul>

<p>Collectively, these constraints are known as the <em>algebraic intermediate representation</em>, or <em>AIR</em>. Advanced STARKs may define more constraint types in order to deal with memory or with consistency of registers within one cycle.</p>

<h3 id="interpolation-and-polynomial-iops">Interpolation and Polynomial IOPs</h3>

<p>Interpolation in the usual sense means finding a polynomial that passes through a set of data points. In the context of the STARK compilation pipeline, <em>interpolation</em> means finding a representation of the arithmetic constraint system in terms of polynomials. The resulting object is not an arithmetic constraint system but an abstract protocol called a <em>Polynomial IOP</em>.</p>

<p>The prover in a regular proof system sends messages to the verifier. But what happens when the verifier is not allowed to read them? Specifically, if the messages from the prover are replaced by oracles, abstract black-box functionalities that the verifier can query in points of his choosing, the protocol is an <em>interactive oracle proof (IOP)</em>. When the oracles correspond to polynomials of low degree, it is a <em>Polynomial IOP</em>. The intuition is that the honest prover obtains a polynomial constraint system whose equations hold, and that the cheating prover must use a constraint system where at least one equation is false. When polynomials are equal, they are equal everywhere, and in particular in random points of the verifier’s choosing. But when polynomials are unequal, they are unequal <em>almost</em> everywhere, and this inequality is exposed with high probability when the verifier probes the left and right hand sides in a random point.</p>

<p>The STARK proof system interpolates the algebraic execution trace literally – that is to say, it finds $\mathsf{w}$ polynomials $t_i(X)$ such that the values $t_i(X)$ takes on a domain $D$ correspond to the algebraic execution trace of the $i$th register. These polynomials are sent as oracles to the verifier. At this point the AIR constraints give rise to operations polynomials that send low-degree polynomials to low-degree polynomials only if the constraints are satisfied. The verifier simulates these operations and can thus derive new polynomials whose low degree certifies the satisfiability of the constraint system, and thus the integrity of the computation. In other words, the interpolation step reduces the satisfiability of an arithmetic constraint system to a claim about the low degree of certain polynomials.</p>

<h3 id="cryptographic-compilation-with-fri">Cryptographic Compilation with FRI</h3>

<p>In the real world, polynomial oracles do not exist. The protocol designer who wants to use a Polynomial IOP as an intermediate stage must find a way to commit to a polynomial and then open that polynomial in a point of the verifier’s choosing. FRI is a key component of a STARK proof that achieves this task by using Merkle trees of Reed-Solomon Codewords to prove the boundedness of a polynomial’s degree.</p>

<p>The Reed-Solomon codeword associated with a polynomial $f(X) \in \mathbb{F}[X]$ is the list of values it takes on a given domain $D \subset \mathbb{F}$. Consider without loss of generality domains $D$ whose cardinality is larger than the maximum allowable degree for polynomials. These values can be put into a Merkle tree, in which case the root represents a commitment to the polynomial. The <em>Fast Reed-Solomon IOP of Proximity (FRI)</em> is a protocol whose prover sends a sequence of Merkle roots corresponding to codewords whose lengths halve in every iteration. The verifier inspects the Merkle trees (specifically: asks the prover to provide the indicated leafs with their authentication paths) of consecutive rounds to test a simple linear relation. For honest provers, the degree of the represented polynomials likewise halves in each round, and is thus much smaller than the length of the codeword. However for malicious provers this degree is one less than the length of the codeword. In the last step, the prover sends a non-trivial codeword corresponding to a constant polynomial.</p>

<p>There is a minor issue the above description does not capture: how does the verifier query a committed polynomial $f(X)$ in a point $z$ that does not belong to the domain? In principle, there is an obvious and straightforward solution: the verifier sends $z$ to the prover, and the prover responds by sending $y=f(z)$. The polynomial $f(X) - y$ has a zero in $X=z$ and so must be divisible by $X-z$. So both prover and verifier have access to a new low degree polynomial, $\frac{f(X) - y}{X-z}$. If the prover was lying about $f(z)=y$, then he is incapable of proving the low degree of $\frac{f(X) - y}{X-z}$, and so his fraud will be exposed in the course of the FRI protocol. This is in fact the exact mechanism that enforces the boundary constraints; a slightly more involved but similar construction enforces the transition constraints. The new polynomials are the result of dividing out known factors, so they will be called <em>quotients</em> and denoted $q_i(X)$.</p>

<p>At this point the Polynomial IOP has been compiled into an interactive concrete proof system. In principle, the protocol could be executed. However, it pays to do one more step of cryptographic compilation: replace the verifier’s random coins (AKA. <em>randomness</em>) by something pseudorandom – but deterministic. This is exactly the Fiat-Shamir transform, and the result is the non-interactive proof known as the STARK.</p>

<p><img src="graphics/stark-overview.svg" alt="The STARK proof system revolves around the transformation of low-degree polynomials into new polynomials whose degree boundedness matches with the integrity of the computation." title="Overview of the compilation pipeline for STARKs" /></p>

<p>This description glosses over many details. The remainder of this tutorial will explain the construction in more concrete and tangible terms, and will insert more fine-grained components into the diagram.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Also, algebraic <em>internal</em> representation. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Note that FRI is defined in terms of abstract oracles which can be queried in arbitrary locations; a FRI protocol can thus be compiled into a concrete protocol by simulating the oracles with any cryptographic vector commitment scheme. Merkle trees provide this functionality but are not the only cryptographic primitive to do it. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

</article>

      </div>
    </main><!-- Parse the Latex divs with Katex-->
<script type="text/javascript">
  $("script[type='math/tex']").replaceWith(
    function(){
      var tex = $(this).text();
      return katex.renderToString(tex, {displayMode: false});
  });
  
  $("script[type='math/tex; mode=display']").replaceWith(
    function(){
      var tex = $(this).text();
      return katex.renderToString(tex.replace(/%.*/g, ''), {displayMode: true});
  });
</script>

</body>

</html>
